# Лабораторная работа №10

## Структуры данных: Stack, Queue, Linked List и бенчмарки

**Цель**: реализовать базовые структуры данных (стек, очередь, связный список), сравнить их производительность и научиться думать в терминах асимптотики (O(1), O(n)).

---

## Краткая теория

### Стек (Stack)

**Определение**: Стек — это структура данных типа LIFO (Last In, First Out — «последним пришёл — первым ушёл»). Элементы добавляются и удаляются только с одного конца, называемого вершиной стека.

**Основные операции**:
- `push(item)` — добавить элемент на вершину стека. **Сложность: O(1)**
- `pop()` — удалить и вернуть верхний элемент. **Сложность: O(1)**
- `peek()` — посмотреть верхний элемент без удаления. **Сложность: O(1)**
- `is_empty()` — проверить, пуст ли стек. **Сложность: O(1)**

**Применение**: обратная польская нотация, парсинг выражений, отслеживание вызовов функций (call stack), отмена операций (undo).

---

### Очередь (Queue)

**Определение**: Очередь — это структура данных типа FIFO (First In, First Out — «первым пришёл — первым ушёл»). Элементы добавляются в конец очереди, а удаляются из начала.

**Основные операции**:
- `enqueue(item)` — добавить элемент в конец очереди. **Сложность: O(1)**
- `dequeue()` — удалить и вернуть первый элемент. **Сложность: O(1)**
- `peek()` — посмотреть первый элемент без удаления. **Сложность: O(1)**
- `is_empty()` — проверить, пуста ли очередь. **Сложность: O(1)**

**Применение**: планировщики задач, обработка запросов, BFS (поиск в ширину), буферизация данных.

---

### Связный список (Linked List)

**Определение**: Связный список — это структура данных, состоящая из узлов (nodes), где каждый узел содержит данные и ссылку на следующий узел. В односвязном списке (Singly Linked List) каждый узел знает только о следующем узле.

**Основные операции**:
- `append(value)` — добавить элемент в конец списка. **Сложность: O(1)** с tail, O(n) без tail
- `prepend(value)` — добавить элемент в начало списка. **Сложность: O(1)**
- `insert(idx, value)` — вставить элемент по индексу. **Сложность: O(n)**
- `remove_at(idx)` — удалить элемент по индексу. **Сложность: O(n)**
- `remove(value)` — удалить первое вхождение значения. **Сложность: O(n)**
- `__iter__()` — итерация по элементам. **Сложность: O(n)**

**Преимущества перед массивами**:
- Динамическое изменение размера
- Вставка/удаление в начало за O(1)
- Не требует непрерывной памяти

**Недостатки**:
- Нет случайного доступа по индексу за O(1)
- Дополнительная память на хранение указателей
- Больше накладных расходов при итерации

---

## Описание реализованных классов

### Stack (`src/lab10/structures.py`)

Класс `Stack` реализован на базе `list`. Вершина стека — последний элемент списка (`self._data[-1]`).

**Пример использования**:
```python
from src.lab10.structures import Stack

stack = Stack()

# Добавление элементов
stack.push(1)
stack.push(2)
stack.push(3)

print(stack.peek())  # 3
print(len(stack))    # 3

# Удаление элементов
print(stack.pop())   # 3
print(stack.pop())   # 2
print(stack.is_empty())  # False
print(stack.pop())   # 1
print(stack.is_empty())  # True
```

**Демонстрация**: см. скриншоты использования через `python -m src.lab10.demo_structures`

---

### Queue (`src/lab10/structures.py`)

Класс `Queue` реализован на базе `collections.deque` для эффективных операций добавления и удаления с обоих концов.

**Пример использования**:
```python
from src.lab10.structures import Queue

queue = Queue()

# Добавление элементов
queue.enqueue("первый")
queue.enqueue("второй")
queue.enqueue("третий")

print(queue.peek())      # "первый"
print(len(queue))        # 3

# Удаление элементов
print(queue.dequeue())   # "первый"
print(queue.dequeue())   # "второй"
print(queue.is_empty())  # False
print(queue.dequeue())   # "третий"
print(queue.is_empty())  # True
```

**Демонстрация**: см. скриншоты использования через `python -m src.lab10.demo_structures`

---

### SinglyLinkedList (`src/lab10/linked_list.py`)

Класс `SinglyLinkedList` реализует односвязный список с поддержкой `tail` для оптимизации операций добавления в конец.

**Пример использования**:
```python
from src.lab10.linked_list import SinglyLinkedList

lst = SinglyLinkedList()

# Добавление элементов
lst.append(1)
lst.append(2)
lst.prepend(0)

print(list(lst))         # [0, 1, 2]
print(len(lst))          # 3
print(str(lst))          # [0] -> [1] -> [2] -> None

# Вставка по индексу
lst.insert(2, 1.5)
print(list(lst))         # [0, 1, 1.5, 2]

# Удаление по индексу
lst.remove_at(1)
print(list(lst))         # [0, 1.5, 2]

# Удаление по значению
lst.remove(1.5)
print(list(lst))         # [0, 2]

# Итерация
for value in lst:
    print(value)         # 0, затем 2
```

**Демонстрация**: см. скриншоты использования через `python -m src.lab10.demo_linked_list`

---

## Бенчмарки и сравнение производительности

Для сравнения производительности были проведены бенчмарки различных операций на разных структурах данных.

### Методика бенчмарков

Бенчмарки запускаются через `python -m src.lab10.benchmarks` и измеряют время выполнения операций на структурах данных разных размеров.

### Результаты и выводы

#### 1. Добавление элементов

- **Stack.push()**: O(1) амортизированно
- **Queue.enqueue()**: O(1)
- **SinglyLinkedList.append()**: O(1) с tail

**Вывод**: Все три структуры показывают константную сложность при добавлении элементов. `deque` (используемый в Queue) и `list` (используемый в Stack) оптимизированы на низком уровне, поэтому работают быстрее связного списка из-за меньших накладных расходов.

#### 2. Удаление элементов

- **Stack.pop()**: O(1) — удаление с конца списка
- **Queue.dequeue()**: O(1) — удаление с начала через `deque.popleft()`
- **SinglyLinkedList.remove_at(0)**: O(1) — удаление из начала

**Вывод**: При удалении из начала списка `deque.popleft()` быстрее, чем удаление из начала обычного `list` (которое было бы O(n)). Связный список также обеспечивает O(1) удаление из начала, но с большими накладными расходами из-за работы с указателями.

#### 3. Доступ по индексу

- **Stack/Queue**: Нет прямого доступа по индексу (но можно использовать `peek()` для первого/верхнего элемента за O(1))
- **SinglyLinkedList**: O(n) — требуется пройти от головы до нужного индекса

**Вывод**: Если нужен случайный доступ, `list` или `array` предпочтительнее связного списка. Однако для последовательного доступа (итерация) разница минимальна.

#### 4. Вставка в середину

- **Stack/Queue**: Не поддерживается напрямую
- **SinglyLinkedList.insert(idx)**: O(n) — требуется найти нужную позицию

**Вывод**: Вставка в середину связного списка имеет линейную сложность, что аналогично вставке в середину `list.insert()` (которая также O(n) из-за сдвига элементов).

#### 5. Память

- **Stack/Queue на базе list/deque**: Компактное хранение, эффективное использование кэша процессора
- **SinglyLinkedList**: Дополнительная память на указатели (overhead), больше cache misses

**Вывод**: Для больших объёмов данных `list`/`deque` более эффективны по памяти и скорости благодаря лучшей локальности данных.

### Итоговые рекомендации

1. **Используйте Stack** когда нужен LIFO порядок (парсинг, отмена операций).
2. **Используйте Queue** когда нужен FIFO порядок (BFS, планировщики, буферы). `deque` обеспечивает O(1) операции с обоих концов.
3. **Используйте SinglyLinkedList** когда нужна частая вставка/удаление в начало или когда размер структуры сильно меняется, но при этом не требуется случайный доступ.

**Важно**: В Python стандартные структуры (`list`, `deque`) обычно быстрее собственных реализаций связных списков из-за оптимизаций на уровне C и лучшей работы с памятью. Связные списки полезны для обучения и понимания структур данных, но на практике часто используются встроенные типы.

---

## Примеры использования через `python -m`

### Демонстрация Stack и Queue

```bash
python -m src.lab10.demo_structures
```

Демонстрирует основные операции со стеком и очередью.

### Демонстрация SinglyLinkedList

```bash
python -m src.lab10.demo_linked_list
```

Демонстрирует основные операции со связным списком, включая красивое текстовое представление.

### Запуск бенчмарков

```bash
python -m src.lab10.benchmarks
```

Запускает бенчмарки производительности для всех реализованных структур данных.

---

## Структура файлов

```
src/lab10/
├── structures.py          # Stack и Queue
├── linked_list.py         # Node и SinglyLinkedList
├── README.md              # Этот файл
├── demo_structures.py     # Демонстрация Stack и Queue
├── demo_linked_list.py    # Демонстрация SinglyLinkedList
└── benchmarks.py          # Бенчмарки производительности
```

---

## Изображения

Скриншоты примеров использования и результатов бенчмарков находятся в папке `images/lab10/`.